<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>AimLab SimplifiÃ©</title>
<style>
body, html { margin:0; padding:0; overflow:hidden; background:#000; font-family:sans-serif;}
#canvas-container { width:100%; height:100%; position:fixed; top:0; left:0;}
#crosshair {position:fixed; top:50%; left:50%; width:3px; height:3px; background:#0f0; transform:translate(-50%,-50%);}
#shoot-btn {position:fixed; bottom:20px; right:20px; width:80px; height:80px; background:red; border-radius:50%; display:none; font-size:2rem; display:flex; align-items:center; justify-content:center; color:white; z-index:10;}
</style>
</head>
<body>
<div id="canvas-container"></div>
<div id="crosshair"></div>
<div id="shoot-btn">ðŸŽ¯</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
let isMobile = 'ontouchstart' in window;
let scene, camera, renderer, raycaster;
let targets = [];
let weaponGroup;
let score = 0;

init();
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0,1.6,0);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    raycaster = new THREE.Raycaster();

    // sol simple
    let floor = new THREE.Mesh(new THREE.PlaneGeometry(50,50), new THREE.MeshStandardMaterial({color:0x222222}));
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    let light = new THREE.DirectionalLight(0xffffff,1);
    light.position.set(10,20,10);
    scene.add(light);

    createWeapon();
    spawnInitialTargets(5);
    animate();

    if(isMobile) setupMobileControls();
    else setupPCControls();

    window.addEventListener('resize', ()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function createWeapon() {
    weaponGroup = new THREE.Group();
    let body = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.6), new THREE.MeshStandardMaterial({color:0x555555}));
    body.position.z = -0.3;
    weaponGroup.add(body);
    camera.add(weaponGroup);
    scene.add(camera);
}

function spawnInitialTargets(count){
    for(let i=0;i<count;i++){
        let t = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshStandardMaterial({color:0xff0000}));
        placeTargetInFront(t);
        scene.add(t);
        targets.push(t);
    }
}

function placeTargetInFront(target){
    // On place la cible devant la camÃ©ra, dans un arc limitÃ©
    let angle = (Math.random() - 0.5) * Math.PI/3; // +/- 30 degrÃ©s
    let distance = 2 + Math.random()*2; // 2 Ã  4 unitÃ©s devant
    let height = 1 + Math.random()*2; // hauteur alÃ©atoire
    let camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    camDir.y = 0;
    camDir.normalize();

    let side = new THREE.Vector3();
    side.crossVectors(new THREE.Vector3(0,1,0), camDir).normalize();
    let pos = camera.position.clone().add(camDir.multiplyScalar(distance)).add(side.multiplyScalar(Math.tan(angle)*distance));
    pos.y = height;
    target.position.copy(pos);
}

function shoot(){
    raycaster.setFromCamera({x:0,y:0}, camera);
    let intersects = raycaster.intersectObjects(targets);
    if(intersects.length>0){
        let target = intersects[0].object;
        score++;
        // Respawn la cible ailleurs devant toi
        placeTargetInFront(target);
        target.material.color.set(0xff0000);
    }
}

function setupPCControls(){
    let isLocked = false;
    renderer.domElement.addEventListener('click',()=>{renderer.domElement.requestPointerLock();});
    document.addEventListener('pointerlockchange',()=>{isLocked = !!document.pointerLockElement;});
    document.addEventListener('mousemove',(e)=>{
        if(!isLocked) return;
        camera.rotation.y -= e.movementX*0.002;
        camera.rotation.x -= e.movementY*0.002;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
    });
    renderer.domElement.addEventListener('mousedown', shoot);
}

function setupMobileControls(){
    document.getElementById('shoot-btn').style.display = 'flex';
    let startX=0, startY=0;
    let isMoving=false;
    document.addEventListener('touchstart',(e)=>{
        if(e.target.id=='shoot-btn'){ shoot(); return; }
        let t = e.touches[0];
        startX = t.clientX; startY = t.clientY;
        isMoving = true;
    });
    document.addEventListener('touchmove',(e)=>{
        if(!isMoving) return;
        let t = e.touches[0];
        let dx = t.clientX - startX;
        let dy = t.clientY - startY;
        camera.rotation.y -= dx*0.002;
        camera.rotation.x -= dy*0.002;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
        startX = t.clientX; startY = t.clientY;
    });
    document.addEventListener('touchend',(e)=>{ isMoving=false; });
}

function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene,camera);
}
</script>
</body>
</html>
