```html
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AimLab 3D Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
            touch-action: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }

        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            padding: 20px;
            overflow-y: auto;
        }

        #menu h1 {
            font-size: clamp(2.5rem, 10vw, 5rem);
            margin-bottom: 50px;
            text-transform: uppercase;
            letter-spacing: 5px;
            background: linear-gradient(45deg, #00f5ff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 245, 255, 0.5);
        }

        .mode-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            width: 100%;
            max-width: 900px;
            margin-bottom: 40px;
        }

        .mode-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid rgba(0, 245, 255, 0.4);
            color: #fff;
            padding: 30px 20px;
            font-size: 1.3rem;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 15px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .mode-btn:hover {
            background: rgba(0, 245, 255, 0.2);
            border-color: #00f5ff;
            transform: scale(1.08);
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.6);
        }

        .mode-btn.selected {
            background: rgba(0, 245, 255, 0.3);
            border-color: #00f5ff;
            box-shadow: 0 0 40px rgba(0, 245, 255, 0.8);
        }

        .mode-desc {
            font-size: 0.8rem;
            margin-top: 10px;
            opacity: 0.7;
            text-transform: none;
            letter-spacing: 1px;
        }

        .sensitivity-control {
            width: 100%;
            max-width: 450px;
            margin-bottom: 40px;
            background: rgba(0, 0, 0, 0.5);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid rgba(0, 245, 255, 0.3);
        }

        .sensitivity-control label {
            display: block;
            margin-bottom: 15px;
            font-size: 1.2rem;
            letter-spacing: 1px;
        }

        .sensitivity-control input {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            border-radius: 5px;
        }

        .sensitivity-control input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 25px;
            height: 25px;
            background: #00f5ff;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }

        #start-btn {
            background: linear-gradient(135deg, #00f5ff, #7b00ff);
            border: none;
            color: #fff;
            padding: 25px 80px;
            font-size: 1.8rem;
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.3s;
            box-shadow: 0 10px 40px rgba(123, 0, 255, 0.6);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        #start-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 50px rgba(123, 0, 255, 0.8);
        }

        #start-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: none;
            z-index: 10;
            pointer-events: none;
        }

        #hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .hud-item {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            border: 2px solid rgba(0, 245, 255, 0.6);
            font-weight: bold;
            letter-spacing: 2px;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #000;
            border-radius: 50%;
            display: none;
            pointer-events: none;
            z-index: 20;
            box-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
        }

        #crosshair.dot {
            width: 4px;
            height: 4px;
            background: #000;
            border-radius: 50%;
        }

        #crosshair.sniper {
            width: 200px;
            height: 200px;
            background: transparent;
            border: 3px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%;
        }

        #crosshair.sniper::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: rgba(0, 255, 0, 0.8);
            transform: translateY(-50%);
        }

        #crosshair.sniper::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(0, 255, 0, 0.8);
            transform: translateX(-50%);
        }

        #hitmarker {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 60px;
            height: 60px;
            display: none;
            pointer-events: none;
            z-index: 25;
        }

        #hitmarker::before,
        #hitmarker::after {
            content: '';
            position: absolute;
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        #hitmarker::before {
            width: 3px;
            height: 25px;
            left: 50%;
            top: -5px;
            transform: translateX(-50%);
        }

        #hitmarker::after {
            width: 3px;
            height: 25px;
            left: 50%;
            bottom: -5px;
            transform: translateX(-50%);
        }

        .hitmarker-line {
            position: absolute;
            background: #00ff00;
            width: 3px;
            height: 25px;
            box-shadow: 0 0 10px #00ff00;
        }

        .hitmarker-line:nth-child(1) {
            left: -5px;
            top: 50%;
            transform: translateY(-50%) rotate(90deg);
        }

        .hitmarker-line:nth-child(2) {
            right: -5px;
            top: 50%;
            transform: translateY(-50%) rotate(90deg);
        }

        #mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: none;
            z-index: 15;
            pointer-events: none;
        }

        #mobile-controls.active {
            pointer-events: auto;
        }

        .joystick-container {
            position: fixed;
            bottom: 40px;
            left: 40px;
            width: 140px;
            height: 140px;
            background: rgba(255, 255, 255, 0.15);
            border: 4px solid rgba(0, 245, 255, 0.6);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }

        .joystick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: rgba(0, 245, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.8);
            pointer-events: none;
        }

        .shoot-btn {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 110px;
            height: 110px;
            background: rgba(255, 50, 50, 0.4);
            border: 5px solid rgba(255, 50, 50, 0.8);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            box-shadow: 0 0 30px rgba(255, 50, 50, 0.6);
            touch-action: none;
        }

        .shoot-btn:active {
            background: rgba(255, 50, 50, 0.7);
            transform: scale(0.92);
        }

        .aim-btn {
            position: fixed;
            bottom: 180px;
            right: 40px;
            width: 90px;
            height: 90px;
            background: rgba(0, 245, 255, 0.4);
            border: 4px solid rgba(0, 245, 255, 0.8);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.6);
            touch-action: none;
        }

        .aim-btn:active {
            background: rgba(0, 245, 255, 0.7);
            transform: scale(0.92);
        }

        #end-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        #end-screen h2 {
            font-size: clamp(2.5rem, 8vw, 4rem);
            margin-bottom: 40px;
            text-transform: uppercase;
            background: linear-gradient(45deg, #00f5ff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stats {
            background: rgba(0, 0, 0, 0.7);
            padding: 40px;
            border-radius: 20px;
            margin-bottom: 40px;
            min-width: 350px;
            border: 3px solid rgba(0, 245, 255, 0.5);
        }

        .stat-line {
            font-size: clamp(1.3rem, 5vw, 1.8rem);
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            gap: 30px;
            letter-spacing: 1px;
        }

        #restart-btn {
            background: linear-gradient(135deg, #00f5ff, #7b00ff);
            border: none;
            color: #fff;
            padding: 20px 60px;
            font-size: 1.5rem;
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.3s;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #restart-btn:hover {
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            .mode-grid {
                grid-template-columns: 1fr;
            }

            .joystick-container {
                width: 120px;
                height: 120px;
                bottom: 30px;
                left: 30px;
            }

            .shoot-btn {
                width: 90px;
                height: 90px;
                bottom: 30px;
                right: 30px;
            }

            .aim-btn {
                width: 70px;
                height: 70px;
                bottom: 140px;
                right: 30px;
            }
        }
    </style>
</head>
<body>
    <div id="menu">
        <h1>AimLab</h1>
        <div class="mode-grid">
            <button class="mode-btn" data-mode="gridshot">
                Gridshot
                <div class="mode-desc">Cibles statiques en grille - Vandal</div>
            </button>
            <button class="mode-btn" data-mode="sixshot">
                Sixshot
                <div class="mode-desc">6 cibles rapides - Vandal</div>
            </button>
            <button class="mode-btn" data-mode="tracking">
                Tracking
                <div class="mode-desc">Suivre la cible - Vandal</div>
            </button>
            <button class="mode-btn" data-mode="sniper">
                Sniper
                <div class="mode-desc">Pr√©cision longue distance - Sniper</div>
            </button>
            <button class="mode-btn" data-mode="spidershot">
                Spidershot
                <div class="mode-desc">Multiples cibles - Vandal</div>
            </button>
        </div>
        <div class="sensitivity-control">
            <label>Sensibilit√©: <span id="sens-value">1.5</span></label>
            <input type="range" id="sensitivity" min="0.3" max="5" step="0.1" value="1.5">
        </div>
        <button id="start-btn" disabled>Choisis un mode</button>
    </div>

    <div id="canvas-container"></div>

    <div id="hud">
        <div id="hud-top">
            <div class="hud-item">SCORE: <span id="score">0</span></div>
            <div class="hud-item">TIME: <span id="timer">60</span></div>
            <div class="hud-item">ACCURACY: <span id="accuracy">100%</span></div>
        </div>
    </div>

    <div id="crosshair" class="dot"></div>
    <div id="hitmarker">
        <div class="hitmarker-line"></div>
        <div class="hitmarker-line"></div>
    </div>

    <div id="mobile-controls">
        <div class="joystick-container">
            <div class="joystick" id="joystick"></div>
        </div>
        <div class="aim-btn" id="aim-btn">üéØ</div>
        <div class="shoot-btn" id="shoot-btn">üí•</div>
    </div>

    <div id="end-screen">
        <h2>R√âSULTATS</h2>
        <div class="stats">
            <div class="stat-line"><span>Score:</span> <span id="final-score">0</span></div>
            <div class="stat-line"><span>Pr√©cision:</span> <span id="final-accuracy">0%</span></div>
            <div class="stat-line"><span>Hits:</span> <span id="final-hits">0</span></div>
        </div>
        <button id="restart-btn">Rejouer</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const isMobile = 'ontouchstart' in window;

        const config = {
            mode: null,
            sensitivity: 1.5,
            gameTime: 60,
            score: 0,
            hits: 0,
            totalShots: 0,
            isPlaying: false,
            targets: [],
            isAiming: false
        };

        const modes = {
            gridshot: {
                targetCount: 1,
                targetSize: 1.2,
                targetSpeed: 0,
                spawnDelay: 0,
                scorePerHit: 100,
                spawnPattern: 'grid',
                weapon: 'vandal',
                mapType: 'training'
            },
            sixshot: {
                targetCount: 6,
                targetSize: 1,
                targetSpeed: 0,
                spawnDelay: 0,
                scorePerHit: 50,
                spawnPattern: 'random',
                weapon: 'vandal',
                mapType: 'training'
            },
            tracking: {
                targetCount: 1,
                targetSize: 1.3,
                targetSpeed: 0.08,
                spawnDelay: 0,
                scorePerHit: 10,
                spawnPattern: 'random',
                continuous: true,
                weapon: 'vandal',
                mapType: 'training'
            },
            sniper: {
                targetCount: 1,
                targetSize: 0.6,
                targetSpeed: 0,
                spawnDelay: 500,
                scorePerHit: 250,
                spawnPattern: 'sniper',
                weapon: 'sniper',
                mapType: 'sniper'
            },
            spidershot: {
                targetCount: 8,
                targetSize: 0.8,
                targetSpeed: 0,
                spawnDelay: 0,
                scorePerHit: 75,
                spawnPattern: 'circle',
                weapon: 'vandal',
                mapType: 'training'
            }
        };

        let scene, camera, renderer, raycaster;
        let weapon, weaponGroup;
        let gameLoop, timerInterval;
        let startTime;
        let keys = {};
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();

        // Mobile controls
        let joystickActive = false;
        let joystickStart = { x: 0, y: 0 };
        let joystickCurrent = { x: 0, y: 0 };
        let touchLookStartX = 0, touchLookStartY = 0;

        // DOM
        const menu = document.getElementById('menu');
        const canvasContainer = document.getElementById('canvas-container');
        const hud = document.getElementById('hud');
        const crosshair = document.getElementById('crosshair');
        const hitmarker = document.getElementById('hitmarker');
        const endScreen = document.getElementById('end-screen');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const modeBtns = document.querySelectorAll('.mode-btn');
        const sensitivitySlider = document.getElementById('sensitivity');
        const sensValue = document.getElementById('sens-value');
        const mobileControls = document.getElementById('mobile-controls');
        const joystickElement = document.getElementById('joystick');
        const shootBtn = document.getElementById('shoot-btn');
        const aimBtn = document.getElementById('aim-btn');

        modeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                modeBtns.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                config.mode = btn.dataset.mode;
                startBtn.disabled = false;
                startBtn.textContent = 'D√âMARRER';
            });
        });

        sensitivitySlider.addEventListener('input', (e) => {
            config.sensitivity = parseFloat(e.target.value);
            sensValue.textContent = config.sensitivity.toFixed(1);
        });

        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', () => {
            endScreen.style.display = 'none';
            menu.style.display = 'flex';
        });

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 50, 150);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.7, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            canvasContainer.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();

            const modeConfig = modes[config.mode];
            if (modeConfig.mapType === 'sniper') {
                createSniperMap();
            } else {
                createTrainingMap();
            }

            createWeapon();
            createTargets();

            window.addEventListener('resize', onWindowResize);

            if (isMobile) {
                setupMobileControls();
            } else {
                setupPCControls();
            }
        }

        function createTrainingMap() {
            // Sol avec texture
            const floorGeometry = new THREE.PlaneGeometry(200, 200);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a4a4a,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Grille au sol
            const gridHelper = new THREE.GridHelper(200, 100, 0x00f5ff, 0x333333);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            // Murs
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a3e,
                roughness: 0.7
            });

            const wallHeight = 10;
            const wallThickness = 1;

            // Mur arri√®re
            const backWallGeometry = new THREE.BoxGeometry(200, wallHeight, wallThickness);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, wallHeight/2, -100);
            backWall.receiveShadow = true;
            scene.add(backWall);

            // Murs lat√©raux
            const sideWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, 200);
            
            const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            leftWall.position.set(-100, wallHeight/2, 0);
            leftWall.receiveShadow = true;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            rightWall.position.set(100, wallHeight/2, 0);
            rightWall.receiveShadow = true;
            scene.add(rightWall);

            // Plafond avec lumi√®re
            const ceilingGeometry = new THREE.PlaneGeometry(200, 200);
            const ceilingMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                roughness: 0.9,
                side: THREE.DoubleSide
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = wallHeight;
            scene.add(ceiling);

            // √âclairage
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(20, 30, 20);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 100;
            mainLight.shadow.camera.left = -50;
            mainLight.shadow.camera.right = 50;
            mainLight.shadow.camera.top = 50;
            mainLight.shadow.camera.bottom = -50;
            scene.add(mainLight);

            // Lumi√®res d'ambiance n√©on
            const neonLight1 = new THREE.PointLight(0x00f5ff, 1, 40);
            neonLight1.position.set(-30, 5, -30);
            scene.add(neonLight1);

            const neonLight2 = new THREE.PointLight(0xff00ff, 1, 40);
            neonLight2.position.set(30, 5, -30);
            scene.add(neonLight2);

            // Plateformes d√©coratives
            addPlatforms();
        }

        function createSniperMap() {
            // Sol d√©sertique
            const floorGeometry = new THREE.PlaneGeometry(300, 300);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0xc2b280,
                roughness: 0.9
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // B√¢timents lointains
            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b7355,
                roughness: 0.8
            });

            for (let i = 0; i < 15; i++) {
                const width = 10 + Math.random() * 10;
                const height = 15 + Math.random() * 20;
                const depth = 10 + Math.random() * 10;
                
                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                
                const angle = (i / 15) * Math.PI * 2;
                const distance = 80 + Math.random() * 60;
                
                building.position.set(
                    Math.cos(angle) * distance,
                    height / 2,
                    Math.sin(angle) * distance
                );
                
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
            }

            // Caisses et obstacles
            const crateMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b6914,
                roughness: 0.7
            });

            for (let i = 0; i < 20; i++) {
                const size = 2 + Math.random() * 2;
                const crateGeometry = new THREE.BoxGeometry(size, size, size);
                const crate = new THREE.Mesh(crateGeometry, crateMaterial);
                
                crate.position.set(
                    (Math.random() - 0.5) * 60,
                    size / 2,
                    (Math.random() - 0.5) * 60 - 20
                );
                
                crate.rotation.y = Math.random() * Math.PI;
                crate.castShadow = true;
                crate.receiveShadow = true;
                scene.add(crate);
            }

            // √âclairage pour environnement ext√©rieur
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffee, 1.2);
            sunLight.position.set(50, 80, 30);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 200;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);
        }

        function addPlatforms() {
            const platformMaterial = new THREE.MeshStandardMaterial({
                color: 0x
```javascript
333344,
                roughness: 0.6,
                metalness: 0.3
            });

            // Plateformes sur√©lev√©es
            const platformPositions = [
                { x: -20, z: -40, width: 8, height: 0.5, depth: 8 },
                { x: 20, z: -40, width: 8, height: 0.5, depth: 8 },
                { x: 0, z: -50, width: 12, height: 0.5, depth: 6 },
                { x: -30, z: -30, width: 6, height: 0.5, depth: 6 },
                { x: 30, z: -30, width: 6, height: 0.5, depth: 6 }
            ];

            platformPositions.forEach(pos => {
                const platformGeometry = new THREE.BoxGeometry(pos.width, pos.height, pos.depth);
                const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                platform.position.set(pos.x, pos.height / 2, pos.z);
                platform.receiveShadow = true;
                platform.castShadow = true;
                scene.add(platform);

                // Bandes n√©on sur les plateformes
                const neonGeometry = new THREE.BoxGeometry(pos.width + 0.2, 0.1, 0.2);
                const neonMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00f5ff,
                    emissive: 0x00f5ff,
                    emissiveIntensity: 1
                });
                const neon = new THREE.Mesh(neonGeometry, neonMaterial);
                neon.position.set(pos.x, pos.height + 0.3, pos.z - pos.depth / 2);
                scene.add(neon);
            });
        }

        function createWeapon() {
            weaponGroup = new THREE.Group();
            const modeConfig = modes[config.mode];

            if (modeConfig.weapon === 'sniper') {
                createSniperRifle();
            } else {
                createVandal();
            }

            weaponGroup.position.set(0.25, -0.25, -0.4);
            camera.add(weaponGroup);
            scene.add(camera);
        }

        function createVandal() {
            // Corps principal de la Vandal
            const bodyGeometry = new THREE.BoxGeometry(0.08, 0.12, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.8,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0, -0.25);
            weaponGroup.add(body);

            // Poign√©e
            const gripGeometry = new THREE.BoxGeometry(0.06, 0.15, 0.08);
            const gripMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.7
            });
            const grip = new THREE.Mesh(gripGeometry, gripMaterial);
            grip.position.set(0, -0.12, 0.05);
            grip.rotation.x = -0.3;
            weaponGroup.add(grip);

            // Canon
            const barrelGeometry = new THREE.CylinderGeometry(0.015, 0.015, 0.35, 12);
            const barrelMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                metalness: 1,
                roughness: 0.1
            });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0.03, -0.45);
            weaponGroup.add(barrel);

            // Chargeur
            const magGeometry = new THREE.BoxGeometry(0.04, 0.15, 0.08);
            const magMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.6,
                roughness: 0.4
            });
            const mag = new THREE.Mesh(magGeometry, magMaterial);
            mag.position.set(0, -0.1, -0.05);
            weaponGroup.add(mag);

            // D√©tails n√©on rouge (signature Vandal)
            const neonGeometry = new THREE.BoxGeometry(0.09, 0.02, 0.15);
            const neonMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0044,
                emissive: 0xff0044,
                emissiveIntensity: 1.5
            });
            const neon = new THREE.Mesh(neonGeometry, neonMaterial);
            neon.position.set(0, 0.07, -0.2);
            weaponGroup.add(neon);

            // Viseur
            const sightGeometry = new THREE.BoxGeometry(0.02, 0.03, 0.02);
            const sightMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                metalness: 0.5
            });
            const sight = new THREE.Mesh(sightGeometry, sightMaterial);
            sight.position.set(0, 0.08, -0.15);
            weaponGroup.add(sight);
        }

        function createSniperRifle() {
            // Corps principal du sniper
            const bodyGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.7);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a3a2a,
                metalness: 0.7,
                roughness: 0.4
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0, -0.35);
            weaponGroup.add(body);

            // Canon long
            const barrelGeometry = new THREE.CylinderGeometry(0.02, 0.018, 0.6, 16);
            const barrelMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                metalness: 1,
                roughness: 0.05
            });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0.03, -0.65);
            weaponGroup.add(barrel);

            // Lunette de vis√©e
            const scopeBodyGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.25, 16);
            const scopeMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.9,
                roughness: 0.2
            });
            const scopeBody = new THREE.Mesh(scopeBodyGeometry, scopeMaterial);
            scopeBody.rotation.z = Math.PI / 2;
            scopeBody.position.set(0, 0.08, -0.3);
            weaponGroup.add(scopeBody);

            // Lentilles de la lunette
            const lensGeometry = new THREE.CircleGeometry(0.028, 16);
            const lensMaterial = new THREE.MeshStandardMaterial({
                color: 0x0066ff,
                emissive: 0x0033ff,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.7
            });
            const frontLens = new THREE.Mesh(lensGeometry, lensMaterial);
            frontLens.position.set(-0.125, 0.08, -0.3);
            frontLens.rotation.y = Math.PI / 2;
            weaponGroup.add(frontLens);

            const backLens = new THREE.Mesh(lensGeometry, lensMaterial);
            backLens.position.set(0.125, 0.08, -0.3);
            backLens.rotation.y = -Math.PI / 2;
            weaponGroup.add(backLens);

            // Crosse
            const stockGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.15);
            const stockMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a2a1a,
                roughness: 0.8
            });
            const stock = new THREE.Mesh(stockGeometry, stockMaterial);
            stock.position.set(0, -0.02, 0.1);
            weaponGroup.add(stock);

            // Poign√©e
            const gripGeometry = new THREE.BoxGeometry(0.05, 0.12, 0.06);
            const gripMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.7
            });
            const grip = new THREE.Mesh(gripGeometry, gripMaterial);
            grip.position.set(0, -0.08, -0.05);
            grip.rotation.x = -0.2;
            weaponGroup.add(grip);

            // Bipied
            const bipodGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.08, 8);
            const bipodMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                metalness: 0.8
            });
            const bipod1 = new THREE.Mesh(bipodGeometry, bipodMaterial);
            bipod1.position.set(-0.03, -0.05, -0.5);
            bipod1.rotation.z = 0.3;
            weaponGroup.add(bipod1);

            const bipod2 = new THREE.Mesh(bipodGeometry, bipodMaterial);
            bipod2.position.set(0.03, -0.05, -0.5);
            bipod2.rotation.z = -0.3;
            weaponGroup.add(bipod2);
        }

        function createTargets() {
            const modeConfig = modes[config.mode];
            config.targets = [];

            for (let i = 0; i < modeConfig.targetCount; i++) {
                // T√™te du bot (cible principale)
                const headGeometry = new THREE.SphereGeometry(modeConfig.targetSize * 0.4, 32, 32);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff3344,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.4,
                    metalness: 0.2,
                    roughness: 0.6
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);

                // Corps du bot
                const bodyGeometry = new THREE.CylinderGeometry(
                    modeConfig.targetSize * 0.35,
                    modeConfig.targetSize * 0.4,
                    modeConfig.targetSize * 1.5,
                    16
                );
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333344,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = -modeConfig.targetSize * 0.95;

                // Groupe pour le bot complet
                const targetGroup = new THREE.Group();
                targetGroup.add(head);
                targetGroup.add(body);

                targetGroup.castShadow = true;
                targetGroup.receiveShadow = true;

                targetGroup.userData = {
                    velocity: new THREE.Vector3(),
                    isActive: true,
                    startTime: Date.now(),
                    head: head,
                    body: body
                };

                positionTarget(targetGroup, i);
                scene.add(targetGroup);
                config.targets.push(targetGroup);
            }
        }

        function positionTarget(target, index = 0) {
            const modeConfig = modes[config.mode];
            
            switch(modeConfig.spawnPattern) {
                case 'grid':
                    const gridCols = 3;
                    const spacing = 10;
                    const row = Math.floor(index / gridCols);
                    const col = index % gridCols;
                    target.position.set(
                        (col - 1) * spacing,
                        1.7,
                        -20 - row * spacing
                    );
                    break;

                case 'circle':
                    const angle = (index / modeConfig.targetCount) * Math.PI * 2;
                    const radius = 20;
                    target.position.set(
                        Math.cos(angle) * radius,
                        1.7,
                        Math.sin(angle) * radius - 25
                    );
                    break;

                case 'sniper':
                    const distance = 40 + Math.random() * 30;
                    const spread = (Math.random() - 0.5) * 40;
                    target.position.set(
                        spread,
                        1.7,
                        -distance
                    );
                    break;

                case 'random':
                default:
                    target.position.set(
                        (Math.random() - 0.5) * 40,
                        1.7,
                        -15 - Math.random() * 30
                    );
                    break;
            }

            if (modeConfig.targetSpeed > 0) {
                target.userData.velocity.set(
                    (Math.random() - 0.5) * modeConfig.targetSpeed,
                    0,
                    (Math.random() - 0.5) * modeConfig.targetSpeed
                );
            }

            target.userData.isActive = true;
            target.userData.startTime = Date.now();
            target.visible = true;
            target.scale.set(0.1, 0.1, 0.1);
            animateTargetSpawn(target);
        }

        function animateTargetSpawn(target) {
            const duration = 200;
            const start = Date.now();
            
            const anim = () => {
                if (!config.isPlaying) return;
                const elapsed = Date.now() - start;
                const progress = Math.min(elapsed / duration, 1);
                const scale = progress;
                
                target.scale.set(scale, scale, scale);
                
                if (progress < 1) {
                    requestAnimationFrame(anim);
                }
            };
            
            anim();
        }

        function setupPCControls() {
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                
                // Vis√©e avec clic droit ou Shift
                if (e.button === 2 || e.code === 'ShiftLeft') {
                    toggleAim(true);
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                
                if (e.button === 2 || e.code === 'ShiftLeft') {
                    toggleAim(false);
                }
            });

            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            document.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    e.preventDefault();
                    toggleAim(true);
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 2) {
                    e.preventDefault();
                    toggleAim(false);
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!config.isPlaying) return;

                const movementX = e.movementX || 0;
                const movementY = e.movementY || 0;

                const rotationSpeed = 0.002 * config.sensitivity * (config.isAiming ? 0.5 : 1);

                camera.rotation.y -= movementX * rotationSpeed;
                camera.rotation.x -= movementY * rotationSpeed;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            });

            renderer.domElement.addEventListener('click', (e) => {
                if (!config.isPlaying) return;
                shoot();
            });

            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });
        }

        function setupMobileControls() {
            mobileControls.classList.add('active');

            const joystickContainer = document.querySelector('.joystick-container');
            
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                const rect = joystickContainer.getBoundingClientRect();
                joystickStart.x = rect.left + rect.width / 2;
                joystickStart.y = rect.top + rect.height / 2;
            });

            document.addEventListener('touchmove', (e) => {
                if (!joystickActive) return;
                
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    const rect = joystickContainer.getBoundingClientRect();
                    
                    if (touch.clientX > rect.left - 50 && 
                        touch.clientX < rect.right + 50 &&
                        touch.clientY > rect.top - 50 && 
                        touch.clientY < rect.bottom + 50) {
                        
                        e.preventDefault();
                        
                        const deltaX = touch.clientX - joystickStart.x;
                        const deltaY = touch.clientY - joystickStart.y;
                        
                        const maxDistance = 50;
                        const distance = Math.min(maxDistance, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                        const angle = Math.atan2(deltaY, deltaX);
                        
                        joystickCurrent.x = Math.cos(angle) * distance;
                        joystickCurrent.y = Math.sin(angle) * distance;
                        
                        joystickElement.style.transform = `translate(calc(-50% + ${joystickCurrent.x}px), calc(-50% + ${joystickCurrent.y}px))`;
                        break;
                    }
                }
            });

            document.addEventListener('touchend', (e) => {
                const rect = joystickContainer.getBoundingClientRect();
                let shouldReset = true;
                
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    if (touch.clientX > rect.left - 50 && 
                        touch.clientX < rect.right + 50 &&
                        touch.clientY > rect.top - 50 && 
                        touch.clientY < rect.bottom + 50) {
                        shouldReset = false;
                        break;
                    }
                }
                
                if (shouldReset) {
                    joystickActive = false;
                    joystickCurrent.x = 0;
                    joystickCurrent.y = 0;
                    joystickElement.style.transform = 'translate(-50%, -50%)';
                }
            });

            let lookTouchId = null;
            
            renderer.domElement.addEventListener('touchstart', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.clientY < window.innerHeight * 0.7 && lookTouchId === null) {
                        lookTouchId = touch.identifier;
                        touchLookStartX = touch.clientX;
                        touchLookStartY = touch.clientY;
                        break;
                    }
                }
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                if (!config.isPlaying || lookTouchId === null) return;
                
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    if (touch.identifier === lookTouchId) {
                        e.preventDefault();
                        
                        const deltaX = touch.clientX - touchLookStartX;
                        const deltaY = touch.clientY - touchLookStartY;

                        const rotationSpeed = 0.004 * config.sensitivity * (config.isAiming ? 0.5 : 1);

                        camera.rotation.y -= deltaX * rotationSpeed;
                        camera.rotation.x -= deltaY * rotationSpeed;
                        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                        touchLookStartX = touch.clientX;
                        touchLookStartY = touch.clientY;
                        break;
                    }
                }
            });

            renderer.domElement.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === lookTouchId) {
                        lookTouchId = null;
                        break;
                    }
                }
            });

            shootBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (config.isPlaying) {
                    shoot();
                }
            });

            aimBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                toggleAim(true);
            });

            aimBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                toggleAim(false);
            });
        }

        function toggleAim(aiming) {
            config.isAiming = aiming;
            const modeConfig = modes[config.mode];

            if (modeConfig.weapon === 'sniper') {
                if (aiming) {
                    crosshair.className = 'sniper';
                    camera.fov = 35;
                    weaponGroup.visible = false;
                } else {
                    crosshair.className = 'dot';
                    camera.fov = 75;
                    weaponGroup.visible = true;
                }
                camera.updateProjectionMatrix();
            }
        }

        function updateMovement(delta) {
            const moveForward = keys['KeyW'] || keys['ArrowUp'];
            const moveBackward = keys['KeyS'] || keys['ArrowDown'];
            const moveLeft = keys['KeyA'] || keys['ArrowLeft'];
            const moveRight = keys['KeyD'] || keys['ArrowRight'];

            let finalMoveForward = moveForward;
            let finalMoveBackward = moveBackward;
            let finalMoveLeft = moveLeft;
            let finalMoveRight = moveRight;

            if (isMobile && joystickActive) {
                const joyX = joystickCurrent.x / 50;
                const joyY = joystickCurrent.y / 50;
                
                finalMoveForward = joyY < -0.2;
                finalMoveBackward = joyY > 0.2;
                finalMoveLeft = joyX < -0.2;
                finalMoveRight = joyX > 0.2;
            }

            velocity.x -= velocity.x * 8.0 * delta;
            velocity.z -= velocity.z * 8.0 * delta;

            direction.z = Number(finalMoveForward) - Number(finalMoveBackward);
            direction.x = Number(finalMoveRight) - Number(finalMoveLeft);
            direction.normalize();

            const speed = 15.0;

            if (finalMoveForward || finalMoveBackward) velocity.z -= direction.z * speed * delta;
            if (finalMoveLeft || finalMoveRight) velocity.x -= direction.x * speed * delta;

            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();

            camera.position.addScaledVector(forward, velocity.z * delta);
            camera.position.addScaledVector(right, velocity.x * delta);

            camera.position.x = Math.max(-90, Math.min(90, camera.position.x));
            camera.position.z = Math.max(-90, Math.min(90, camera.position.z));
            camera.position.y = 1.7;
        }

        function shoot() {
            if (!config.isPlaying) return;

            config.totalShots++;

            weaponGroup.position.z = -0.35;
            weaponGroup.rotation.x = 0.05;
            setTimeout(() => {
                weaponGroup.position.z = -0.4;
                weaponGroup.rotation.x = 0;
            }, 80);

            const muzzleFlash = new THREE.PointLight(0xffaa00, 3, 10);
            muzzleFlash.position.copy(camera.position);
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            muzzleFlash.position.add(forward.multiplyScalar(0.5));
            scene.add(muzzleFlash);
            setTimeout(() => scene.remove(muzzleFlash), 50);

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            raycaster.set(camera.position, direction);

            const intersects = raycaster.intersectObjects(config.targets, true);

            if (intersects.length > 0) {
                let hitTarget = null;
                for (let intersect of intersects) {
                    if (intersect.object.parent && config.targets.includes(intersect.object.parent)) {
                        hitTarget = intersect.object.parent;
                        break;
                    }
                }

                if (hitTarget && hitTarget.userData.isActive) {
                    onHitTarget(hitTarget);
                }
            }

            updateAccuracy();
        }

        function onHitTarget(target) {
            config.hits++;
            const modeConfig = modes[config.mode];
            config.score += modeConfig.scorePerHit;
            updateHUD();

            showHitmarker();

            target.userData.head.material.color.setHex(0x00ff00);
            target.userData.head.material.emissive.setHex(0x00ff00);
            target.userData.head.material.emissiveIntensity = 1;

            setTimeout(() => {
                if (target.userData.head.material) {
                    target.userData.head.material.color.setHex(0xff3344);
                    target.userData.head.material.emissive.setHex(0xff0000);
                    target.userData.head.material.emissiveIntensity = 0.4;
                }
            }, 100);

            target.userData.isActive = false;

            if (modeConfig.continuous) {
                setTimeout(() => {
                    if (config.isPlaying) {
                        positionTarget(target);
                    }
                }, 150);
            } else {
                target.scale.set(1, 1, 1);
                const shrinkDuration = 180;
                const shrinkStart = Date.now();
                
                const shrink = () => {
                    if (!config.isPlaying) return;
                    const elapsed = Date.now() - shrinkStart;
                    const progress = Math.min(elapsed / shrinkDuration, 1);
                    const scale = 1 - progress;
                    
                    target.scale.set(scale, scale, scale);
                    
                    if (progress < 1) {
                        requestAnimationFrame(shrink);
                    } else {
                        setTimeout(() => {
                            if (config.isPlaying) {
                                positionTarget(target);
                            }
                        }, modeConfig.spawnDelay);
                    }
                };
                
                shrink();
            }
        }

        function showHitmarker() {
            hitmarker.style.display = 'block';
            setTimeout(() => {
                hitmarker.style.display = 'none';
            }, 100);
        }

        function updateTargets() {
            const modeConfig = modes[config.mode];

            config.targets.forEach(target => {
                if (!target.userData.isActive && !modeConfig.continuous) return;

                if (modeConfig.targetSpeed > 0) {
                    target.position.add(target.userData.velocity);

                    const limitX = 35;
                    const limitZ = 70;

                    if (Math.abs(target.position.x) > limitX) {
                        target.userData.velocity.x *= -1;
                        target.position.x = Math.sign(target.position.x) * limitX;
                    }
                    if (target.position.z > -5 || target.position.z < -limitZ) {
                        target.userData.velocity.z *= -1;
                        target.position.z = Math.max(-limitZ, Math.min(-5, target.position.z));
                    }
                }

                target.rotation.y += 0.01;
            });
        }

        function updateHUD() {
            document.getElementById('score').textContent = config.score;
        }

        function updateAccuracy() {
            const accuracy = config.totalShots > 0 ? Math.round((config.hits / config.totalShots) * 100) : 100;
            document.getElementById('accuracy').textContent = accuracy + '%';
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const remaining = Math.max(0, config.gameTime - elapsed);
            document.getElementById('timer').textContent = remaining;

            if (remaining <= 0) {
                endGame();
            }
        }

        function animate() {
            if (!config.isPlaying) return;

            gameLoop = requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            updateMovement(delta);
            updateTargets();

            renderer.render(scene, camera);

            prevTime = time;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function startGame() {
            if (!config.mode) return;

            config.score = 0;
            config.hits = 0;
            config.totalShots = 0;
            config.isPlaying = true;
            config.isAiming = false;
            startTime = Date.now();
            prevTime = performance.now();

            menu.style.display = 'none';
```javascript
            canvasContainer.style.display = 'block';
            hud.style.display = 'block';
            crosshair.style.display = 'block';

            if (isMobile) {
                mobileControls.style.display = 'block';
            }

            initThree();
            updateHUD();
            updateAccuracy();
            timerInterval = setInterval(updateTimer, 1000);
            animate();
        }

        function endGame() {
            config.isPlaying = false;
            clearInterval(timerInterval);
            cancelAnimationFrame(gameLoop);

            if (document.pointerLockElement) {
                document.exitPointerLock();
            }

            config.targets.forEach(target => {
                scene.remove(target);
                if (target.userData.head) {
                    target.userData.head.geometry.dispose();
                    target.userData.head.material.dispose();
                }
                if (target.userData.body) {
                    target.userData.body.geometry.dispose();
                    target.userData.body.material.dispose();
                }
            });
            config.targets = [];

            if (weaponGroup) {
                weaponGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                scene.remove(camera);
            }

            scene.traverse((object) => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });

            renderer.dispose();
            canvasContainer.innerHTML = '';

            const accuracy = config.totalShots > 0 ? Math.round((config.hits / config.totalShots) * 100) : 0;

            document.getElementById('final-score').textContent = config.score;
            document.getElementById('final-accuracy').textContent = accuracy + '%';
            document.getElementById('final-hits').textContent = config.hits;

            hud.style.display = 'none';
            crosshair.style.display = 'none';
            mobileControls.style.display = 'none';
            canvasContainer.style.display = 'none';
            endScreen.style.display = 'flex';
        }
    </script>
</body>
</html>
```